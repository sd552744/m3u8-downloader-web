import React, { useState, useEffect } from 'react';
import {
  Container,
  CssBaseline,
  ThemeProvider,
  AppBar,
  Toolbar,
  Typography,
  Box,
  Snackbar,
  Alert,
  Button,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Chip,
  IconButton,
} from '@mui/material';
import {
  Download as DownloadIcon,
  CheckCircle,
  Delete,
  Settings as SettingsIcon,
  Add as AddIcon,
} from '@mui/icons-material';
import { theme } from './styles/theme';
import DownloadingTasks from './components/DownloadingTasks';
import CompletedTasks from './components/CompletedTasks';
import RecycleBin from './components/RecycleBin';
import TaskForm from './components/TaskForm';
import SystemStatus from './components/SystemStatus';
import SettingsDialog from './components/SettingsDialog';
import { DownloadTask, SystemInfo, DownloadRequest } from './types';
import { taskApi, systemApi } from './services/api';

type ViewType = 'downloading' | 'completed' | 'recycle';

function App() {
  const [currentView, setCurrentView] = useState<ViewType>('downloading');
  const [tasks, setTasks] = useState<DownloadTask[]>([]);
  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null);
  const [showTaskForm, setShowTaskForm] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' as 'success' | 'error' });

  const loadTasks = async () => {
    try {
      const data = await taskApi.getTasks();
      setTasks(data);
    } catch (error) {
      console.error('Failed to load tasks:', error);
      showMessage('Âä†ËΩΩ‰ªªÂä°Â§±Ë¥•', 'error');
    }
  };

  const loadSystemInfo = async () => {
    try {
      const data = await systemApi.getInfo();
      setSystemInfo(data);
    } catch (error) {
      console.error('Failed to load system info:', error);
    }
  };

  const showMessage = (message: string, severity: 'success' | 'error') => {
    setSnackbar({ open: true, message, severity });
  };

  useEffect(() => {
    loadTasks();
    loadSystemInfo();
    
    const interval = setInterval(() => {
      loadTasks();
      loadSystemInfo();
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  // ËøáÊª§‰ªªÂä°Êï∞ÊçÆ
  const downloadingTasks = tasks.filter(task => 
    ['downloading', 'paused', 'pending', 'queued'].includes(task.status)
  );
  
  const completedTasks = tasks.filter(task => 
    task.status === 'completed'
  );
  
  const recycleTasks = tasks.filter(task => 
    task.status === 'deleted'
  );

  const handleCreateTask = async (taskData: DownloadRequest) => {
    try {
      // Â∫îÁî®ËÆæÁΩÆ‰∏≠ÁöÑÁ∫øÁ®ãÊï∞
      const settings = localStorage.getItem('m3u8-downloader-settings');
      if (settings) {
        const { maxThreads } = JSON.parse(settings);
        taskData.max_threads = maxThreads || 10;
      } else {
        taskData.max_threads = 10; // ÈªòËÆ§10Á∫øÁ®ã
      }
      
      await taskApi.createTask(taskData);
      showMessage(`‰ªªÂä°ÂàõÂª∫ÊàêÂäü: ${taskData.filename}`, 'success');
      setShowTaskForm(false);
      loadTasks();
    } catch (error: any) {
      const errorMsg = error.response?.data?.detail || error.message;
      showMessage(`ÂàõÂª∫‰ªªÂä°Â§±Ë¥•: ${errorMsg}`, 'error');
      throw error;
    }
  };

  const handlePauseTask = async (taskId: string) => {
    try {
      await taskApi.pauseTask(taskId);
      showMessage('‰ªªÂä°Â∑≤ÊöÇÂÅú', 'success');
      loadTasks();
    } catch (error) {
      showMessage('ÊöÇÂÅú‰ªªÂä°Â§±Ë¥•', 'error');
    }
  };

  const handleResumeTask = async (taskId: string) => {
    try {
      await taskApi.resumeTask(taskId);
      showMessage('‰ªªÂä°Â∑≤ÊÅ¢Â§ç', 'success');
      loadTasks();
    } catch (error) {
      showMessage('ÊÅ¢Â§ç‰ªªÂä°Â§±Ë¥•', 'error');
    }
  };

  const handleDeleteTask = async (taskId: string) => {
    try {
      await fetch(`http://localhost:8000/api/files/${taskId}`, { 
        method: 'DELETE' 
      });
      showMessage('‰ªªÂä°Â∑≤ÁßªÂà∞ÂõûÊî∂Á´ô', 'success');
      loadTasks();
    } catch (error) {
      showMessage('Âà†Èô§‰ªªÂä°Â§±Ë¥•', 'error');
    }
  };

  const handlePermanentDelete = async (taskId: string) => {
    try {
      await taskApi.deleteTask(taskId);
      showMessage('‰ªªÂä°Â∑≤Ê∞∏‰πÖÂà†Èô§', 'success');
      loadTasks();
    } catch (error) {
      showMessage('Ê∞∏‰πÖÂà†Èô§Â§±Ë¥•', 'error');
    }
  };

  const handleRestoreTask = async (taskId: string) => {
    try {
      const response = await fetch(`http://localhost:8000/api/tasks/${taskId}/restore`, {
        method: 'POST',
      });
      
      if (response.ok) {
        showMessage('‰ªªÂä°Â∑≤ËøòÂéü', 'success');
        loadTasks();
      } else {
        throw new Error('ËøòÂéüÂ§±Ë¥•');
      }
    } catch (error) {
      showMessage('ËøòÂéü‰ªªÂä°Â§±Ë¥•', 'error');
    }
  };

  const handleDownloadFile = async (taskId: string, filename: string) => {
    try {
      console.log(`ÂºÄÂßã‰∏ãËΩΩÊñá‰ª∂: ${filename}, ‰ªªÂä°ID: ${taskId}`);
      
      const response = await fetch(`http://localhost:8000/api/files/${taskId}/download`);
      
      if (!response.ok) {
        throw new Error(`‰∏ãËΩΩÂ§±Ë¥•: ${response.status} ${response.statusText}`);
      }
      
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
      
      showMessage('Êñá‰ª∂‰∏ãËΩΩÂÆåÊàê', 'success');
      
    } catch (error: any) {
      console.error('‰∏ãËΩΩÊñá‰ª∂Â§±Ë¥•:', error);
      showMessage(`Êñá‰ª∂‰∏ãËΩΩÂ§±Ë¥•: ${error.message}`, 'error');
    }
  };

  const handleClearCache = async () => {
    try {
      const response = await fetch('http://localhost:8000/api/system/cleanup-all', {
        method: 'POST'
      });
      
      if (response.ok) {
        showMessage('ÁºìÂ≠òÊ∏ÖÁêÜÂÆåÊàê', 'success');
        loadTasks();
      } else {
        throw new Error('Ê∏ÖÁêÜÂ§±Ë¥•');
      }
    } catch (error) {
      showMessage('ÁºìÂ≠òÊ∏ÖÁêÜÂ§±Ë¥•', 'error');
    }
  };

  const handleUpdateConcurrency = async (maxTasks: number) => {
    try {
      const response = await fetch('http://localhost:8000/api/system/update-concurrency', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ max_tasks: maxTasks })
      });
      
      if (response.ok) {
        showMessage(`Âπ∂Âèë‰ªªÂä°Êï∞Â∑≤Êõ¥Êñ∞‰∏∫ ${maxTasks}`, 'success');
        loadSystemInfo();
      } else {
        throw new Error('Êõ¥Êñ∞Â§±Ë¥•');
      }
    } catch (error) {
      showMessage('Êõ¥Êñ∞Âπ∂Âèë‰ªªÂä°Êï∞Â§±Ë¥•', 'error');
    }
  };

  const handleEmptyRecycleBin = async () => {
    if (window.confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÂõûÊî∂Á´ôÂêóÔºüÊ≠§Êìç‰ΩúÂ∞ÜÊ∞∏‰πÖÂà†Èô§ÊâÄÊúâÊñá‰ª∂ÔºåÊó†Ê≥ïÊÅ¢Â§çÔºÅ')) {
      try {
        const deletePromises = recycleTasks.map(task => 
          taskApi.deleteTask(task.task_id)
        );
        await Promise.all(deletePromises);
        showMessage('ÂõûÊî∂Á´ôÂ∑≤Ê∏ÖÁ©∫', 'success');
        loadTasks();
      } catch (error) {
        showMessage('Ê∏ÖÁ©∫ÂõûÊî∂Á´ôÂ§±Ë¥•', 'error');
      }
    }
  };

  const getViewTitle = () => {
    switch (currentView) {
      case 'downloading': return '‰∏ãËΩΩ‰∏≠';
      case 'completed': return 'Â∑≤ÂÆåÊàê';
      case 'recycle': return 'ÂõûÊî∂Á´ô';
      default: return '‰ªªÂä°ÂàóË°®';
    }
  };

  const drawerWidth = 200;

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      
      <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
        <Toolbar>
          <Typography variant="h5" component="h1" sx={{ flexGrow: 1, fontWeight: 'bold' }}>
            üé¨ M3U8 ‰∏ãËΩΩÂô® Pro
          </Typography>
          
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <IconButton 
              color="inherit"
              onClick={() => setShowSettings(true)}
              title="ËÆæÁΩÆ"
            >
              <SettingsIcon />
            </IconButton>
          </Box>
        </Toolbar>
      </AppBar>

      <Drawer
        variant="permanent"
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          [`& .MuiDrawer-paper`]: { 
            width: drawerWidth, 
            boxSizing: 'border-box',
            top: '64px'
          },
        }}
      >
        <Toolbar />
        <Box sx={{ overflow: 'auto', mt: 2 }}>
          <List>
            <ListItem 
              button 
              selected={currentView === 'downloading'}
              onClick={() => setCurrentView('downloading')}
            >
              <ListItemIcon>
                <DownloadIcon color={currentView === 'downloading' ? 'primary' : 'inherit'} />
              </ListItemIcon>
              <ListItemText primary="‰∏ãËΩΩ‰∏≠" />
              {downloadingTasks.length > 0 && (
                <Chip label={downloadingTasks.length} size="small" color="primary" />
              )}
            </ListItem>
            
            <ListItem 
              button 
              selected={currentView === 'completed'}
              onClick={() => setCurrentView('completed')}
            >
              <ListItemIcon>
                <CheckCircle color={currentView === 'completed' ? 'primary' : 'inherit'} />
              </ListItemIcon>
              <ListItemText primary="Â∑≤ÂÆåÊàê" />
              {completedTasks.length > 0 && (
                <Chip label={completedTasks.length} size="small" color="success" />
              )}
            </ListItem>
            
            <ListItem 
              button 
              selected={currentView === 'recycle'}
              onClick={() => setCurrentView('recycle')}
            >
              <ListItemIcon>
                <Delete color={currentView === 'recycle' ? 'primary' : 'inherit'} />
              </ListItemIcon>
              <ListItemText primary="ÂõûÊî∂Á´ô" />
              {recycleTasks.length > 0 && (
                <Chip label={recycleTasks.length} size="small" color="error" />
              )}
            </ListItem>
          </List>
        </Box>
      </Drawer>

      <Box sx={{ ml: `${drawerWidth}px`, p: 3 }}>
        <Toolbar />
        
        <SystemStatus info={systemInfo} />
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h4" component="h2">
            {getViewTitle()}
          </Typography>
          
          {currentView === 'downloading' && (
            <Button
              variant="contained"
              startIcon={<AddIcon />}
              onClick={() => setShowTaskForm(true)}
            >
              Êñ∞Âª∫‰ªªÂä°
            </Button>
          )}
          
          {currentView === 'recycle' && recycleTasks.length > 0 && (
            <Button
              variant="outlined"
              color="error"
              startIcon={<Delete />}
              onClick={handleEmptyRecycleBin}
            >
              Ê∏ÖÁ©∫ÂõûÊî∂Á´ô
            </Button>
          )}
        </Box>

        {currentView === 'downloading' && (
          <DownloadingTasks
            tasks={downloadingTasks}
            onPause={handlePauseTask}
            onResume={handleResumeTask}
            onDelete={handleDeleteTask}
          />
        )}
        
        {currentView === 'completed' && (
          <CompletedTasks
            tasks={completedTasks}
            onDownload={handleDownloadFile}
            onDelete={handleDeleteTask}
          />
        )}
        
        {currentView === 'recycle' && (
          <RecycleBin
            tasks={recycleTasks}
            onRestore={handleRestoreTask}
            onPermanentDelete={handlePermanentDelete}
            onEmptyRecycleBin={handleEmptyRecycleBin}
          />
        )}
      </Box>

      {showTaskForm && (
        <TaskForm
          onSubmit={handleCreateTask}
          onClose={() => setShowTaskForm(false)}
        />
      )}

      <SettingsDialog
        open={showSettings}
        onClose={() => setShowSettings(false)}
        onClearCache={handleClearCache}
        onUpdateConcurrency={handleUpdateConcurrency}
        systemInfo={systemInfo}
      />

      <Snackbar
        open={snackbar.open}
        autoHideDuration={4000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
      >
        <Alert severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </ThemeProvider>
  );
}

export default App;
